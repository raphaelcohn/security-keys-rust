// This file is part of security-keys-rust. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/security-keys-rust/master/COPYRIGHT. No part of security-keys-rust, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
// Copyright Â© 2021 The developers of security-keys-rust. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/raphaelcohn/security-keys-rust/master/COPYRIGHT.


extern "C"
{
	/// ***Only one thread at a time can call this for a particular `Lun`.***.
	///
	/// This function is required to open a communications channel to the port listed by `DeviceName`.
	///
	/// Once the channel is opened the reader must be in a state in which it is possible to query `IFDHICCPresence()` for card status.
	///
	/// * `Lun`:  Logical Unit Number, also called `slot`.
	/// * `DeviceName`: 'Filename to use by the driver' or USB string; a non-null C String with a `strlen()` greater than 0.
	///
	///
	/// ## Device Name
	///
	/// For drivers configured by `/etc/reader.conf` (the legacy Gemplus Twin Serial drivers), this is the value of the field `DEVICENAME`. For USB drivers the `DeviceName` must start with `usb:VID/PID`, where:-
	///
	/// * `VID` is the Vendor Identifier as a 4 digit lowercase hexadecimal number;
	/// * `PID` is the Product Identifier as a 4 digit lowercase hexadecimal number.
	///
	/// For example, `usb:ab12/ff00`.
	///
	///
	/// ### Additional Information for USB card readers
	///
	/// The `DeviceName` string may also contain a more specialised identification string.
	///
	/// This additional information is used to differentiate between two identical readers connected at the same time. In this case the driver cannot differentiate the two readers using Vendor Identifier and Product Identifier and PID and must use some additional information identifying the USB port used by each reader.
	///
	/// This varies whether the driver uses `libusb` or `libudev`; the latter is the new default.
	/// If a driver does not understand the additional information, it should ignore it rather than fail.
	///
	///
	/// #### `libusb`
	///
	/// For USB drivers using libusb-1.0 http://libusb.sourceforge.net/ for USB abstraction the `DeviceName` the string may be generated by the C code `printf("usb:%04x/%04x:libusb-1.0:%d:%d:%d", idVendor, idProduct, bus_number, device_address, interface)`.
	///
	/// An example might be `usb:08e6/3437:libusb-1.0:7:99:0` under Linux (this may be different for Mac OS X).
	///
	///
	/// #### `libudev`
	///
	/// If using `libudev`, the string may be generated by the C code `printf("usb:%04x/%04x:libudev:%d:%s", idVendor, idProduct, bInterfaceNumber, devpath)` where:-
	///
	/// * `bInterfaceNumber` is the number of the interface on the device. It is only useful for devices with more than one CCID interface.
	/// * `devpath` is the filename of the device on the file system; it is obtained by the API function `udev_device_get_devnode()`.
	///
	/// An example might be `usb:08e6/3437:libudev:0:/dev/bus/usb/008/047` under Linux.
	///
	///
	/// # Return Codes
	///
	/// * `IFD_SUCCESS`: Successful.
	/// * `IFD_COMMUNICATION_ERROR`: Error has occurred.
	/// * `IFD_NO_SUCH_DEVICE`: The reader is no more present.
	pub(in crate::ifdhandler) fn IFDHCreateChannelByName(Lun: DWORD, DeviceName: *mut c_char) -> RESPONSECODE;
}
