// This file is part of security-keys-rust. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/security-keys-rust/master/COPYRIGHT. No part of security-keys-rust, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
// Copyright Â© 2021 The developers of security-keys-rust. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/security-keys-rust/master/COPYRIGHT.


extern "C"
{
	/// This function is required to open a communications channel to the port listed by `DeviceName`.
	///
	/// Once the channel is opened the reader must be in a state in which it is possible to query `IFDHICCPresence()` for card status.
	///
	/// @ingroup IFDHandler
	/// @param[in] Lun Logical Unit Number\\n
	/// Use this for multiple card slots or multiple readers. 0xXXXXYYYY -
	/// XXXX multiple readers, YYYY multiple slots. The resource manager will
	/// set these automatically. By default the resource manager loads a new
	/// instance of the driver so if your reader does not have more than one
	/// smart card slot then ignore the Lun in all the functions.\\n
	/// \\n
	/// PC/SC supports the loading of multiple readers through one instance of
	/// the driver in which XXXX is important. XXXX identifies the unique
	/// reader in which the driver communicates to. The driver should set up
	/// an array of structures that asociate this XXXX with the underlying
	/// details of the particular reader.
	///
	/// @param[in] DeviceName Filename to use by the driver.\\n
	/// For drivers configured by @p /etc/reader.conf this is the value of the
	/// field \\ref DEVICENAME.
	/// \\n
	/// For USB drivers the @p DeviceName must start with @p usb:VID/PID. VID
	/// is the Vendor ID and PID is the Product ID. Both are a 4-digits hex
	/// number.
	///
	/// Typically the string is generated by:
	///
	/// @code
	/// printf(\"usb:%04x/%04x\", idVendor, idProduct);
	/// @endcode
	///
	/// The @p DeviceName string may also contain a more specialised
	/// identification string. This additional information is used to
	/// differentiate between two identical readers connected at the same time.
	/// In this case the driver can't differentiate the two readers using VID
	/// and PID and must use some additional information identifying the USB
	/// port used by each reader.
	///
	/// - libusb
	///
	/// For USB drivers using libusb-1.0 http://libusb.sourceforge.net/ for USB
	/// abstraction the @p DeviceName the string may be generated by:
	///
	/// @code
	/// printf(\"usb:%04x/%04x:libusb-1.0:%d:%d:%d\",
	/// idVendor, idProduct, bus_number, device_address, interface)
	/// @endcode
	///
	/// So it is something like: <tt>usb:08e6/3437:libusb-1.0:7:99:0</tt> under
	/// GNU/Linux.
	///
	/// - libudev
	///
	/// If pcscd is compiled with libudev support instead of libusb (default
	/// since pcsc-lite 1.6.8) the string will look like:
	///
	/// @code
	/// printf(\"usb:%04x/%04x:libudev:%d:%s\", idVendor, idProduct,
	/// bInterfaceNumber, devpath);
	/// @endcode
	///
	/// bInterfaceNumber is the number of the interface on the device. It is
	/// only usefull for devices with more than one CCID interface.
	///
	/// devpath is the filename of the device on the file system.
	///
	/// So it is something like:
	/// <tt>usb:08e6/3437:libudev:0:/dev/bus/usb/008/047</tt>
	/// under GNU/Linux.
	///
	/// - other
	///
	/// If the driver does not understand the <tt>:libusb:</tt> or
	/// <tt>:libudev:</tt> scheme or if a new scheme is used, the driver should
	/// ignore the part it does not understand instead of failing.
	///
	/// The driver shall recognize the <tt>usb:VID/PID</tt> part and, only if
	/// possible, the remaining of the DeviceName field.
	///
	/// It is the responsibility of the driver to correctly identify the reader.
	///
	/// @return Error codes
	/// @retval IFD_SUCCESS Successful (\\ref IFD_SUCCESS)
	/// @retval IFD_COMMUNICATION_ERROR Error has occurred (\\ref IFD_COMMUNICATION_ERROR)
	/// @retval IFD_NO_SUCH_DEVICE The reader is no more present (\\ref IFD_NO_SUCH_DEVICE)
	pub(in crate::ifdhandler) fn IFDHCreateChannelByName(Lun: DWORD, DeviceName: *mut c_char) -> RESPONSECODE;
}
